"use strict";var EventEmitter=require("events").EventEmitter;var JSON=require("json3");var Pending=require("./pending");var debug=require("debug")("mocha:runnable");var milliseconds=require("./ms");var utils=require("./utils");var create=require("lodash.create");var Date=global.Date;var setTimeout=global.setTimeout;var setInterval=global.setInterval;var clearTimeout=global.clearTimeout;var clearInterval=global.clearInterval;var toString=Object.prototype.toString;module.exports=Runnable;function Runnable(b,a){this.title=b;this.fn=a;this.body=(a||"").toString();this.async=a&&a.length;this.sync=!this.async;this._timeout=2000;this._slow=75;this._enableTimeouts=true;this.timedOut=false;this._trace=new Error("done() called multiple times");this._retries=-1;this._currentRetry=0;this.pending=false}Runnable.prototype=create(EventEmitter.prototype,{constructor:Runnable});Runnable.prototype.timeout=function(a){if(!arguments.length){return this._timeout}if(a===0||a>Math.pow(2,31)){this._enableTimeouts=false}if(typeof a==="string"){a=milliseconds(a)}debug("timeout %d",a);this._timeout=a;if(this.timer){this.resetTimeout()}return this};Runnable.prototype.slow=function(a){if(typeof a==="undefined"){return this._slow}if(typeof a==="string"){a=milliseconds(a)}debug("timeout %d",a);this._slow=a;return this};Runnable.prototype.enableTimeouts=function(a){if(!arguments.length){return this._enableTimeouts}debug("enableTimeouts %s",a);this._enableTimeouts=a;return this};Runnable.prototype.skip=function(){throw new Pending("sync skip")};Runnable.prototype.isPending=function(){return this.pending||(this.parent&&this.parent.isPending())};Runnable.prototype.retries=function(a){if(!arguments.length){return this._retries}this._retries=a};Runnable.prototype.currentRetry=function(a){if(!arguments.length){return this._currentRetry}this._currentRetry=a};Runnable.prototype.fullTitle=function(){return this.parent.fullTitle()+" "+this.title};Runnable.prototype.clearTimeout=function(){clearTimeout(this.timer)};Runnable.prototype.inspect=function(){return JSON.stringify(this,function(a,b){if(a[0]==="_"){return}if(a==="parent"){return"#<Suite>"}if(a==="ctx"){return"#<Context>"}return b},2)};Runnable.prototype.resetTimeout=function(){var a=this;var b=this.timeout()||1000000000;if(!this._enableTimeouts){return}this.clearTimeout();this.timer=setTimeout(function(){if(!a._enableTimeouts){return}a.callback(new Error("Timeout of "+b+'ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.'));a.timedOut=true},b)};Runnable.prototype.globals=function(a){if(!arguments.length){return this._allowedGlobals}this._allowedGlobals=a};Runnable.prototype.run=function(i){var j=this;var c=new Date();var k=this.ctx;var e;var h;if(k&&k.runnable){k.runnable(this)}function l(m){if(h){return}h=true;j.emit("error",m||new Error("done() called multiple times; stacktrace may be inaccurate"))}function g(n){var m=j.timeout();if(j.timedOut){return}if(e){return l(n||j._trace)}j.clearTimeout();j.duration=new Date()-c;e=true;if(!n&&j.duration>m&&j._enableTimeouts){n=new Error("Timeout of "+m+'ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.')}i(n)}this.callback=g;if(this.async){this.resetTimeout();this.skip=function f(){g(new Pending("async skip call"));throw new Pending("async skip; aborting execution")};if(this.allowUncaught){return a(this.fn)}try{a(this.fn)}catch(d){h=true;g(utils.getError(d))}return}if(this.allowUncaught){if(this.isPending()){g()}else{b(this.fn)}return}try{if(this.isPending()){g()}else{b(this.fn)}}catch(d){h=true;g(utils.getError(d))}function b(n){var m=n.call(k);if(m&&typeof m.then==="function"){j.resetTimeout();m.then(function(){g();return null},function(o){g(o||new Error("Promise rejected with no or falsy reason"))})}else{if(j.asyncOnly){return g(new Error("--async-only option in use without declaring `done()` or returning a promise"))}g()}}function a(n){var m=n.call(k,function(o){if(o instanceof Error||toString.call(o)==="[object Error]"){return g(o)}if(o){if(Object.prototype.toString.call(o)==="[object Object]"){return g(new Error("done() invoked with non-Error: "+JSON.stringify(o)))}return g(new Error("done() invoked with non-Error: "+o))}if(m&&utils.isPromise(m)){return g(new Error("Resolution method is overspecified. Specify a callback *or* return a Promise; not both."))}g()})}};